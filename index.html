<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Chewbooty Roster</title>
  <style>
    :root{
      --bg:#0f0f10;
      --panel:#1b1b1d;
      --panel-2:#151516;
      --muted:#bdbdbd;
      --accent:#ffd166;
      --link:#66d9ff;
      --green:#00ff88;
      --red:#ff6b6b;
      --shadow: rgba(0,0,0,0.55);
      --badge-1: linear-gradient(90deg,#ffd166,#ffb86b);
      --badge-2: linear-gradient(90deg,#c7f0ff,#66d9ff);
      --badge-3: linear-gradient(90deg,#d6f7d6,#9be564);
    }

    body { font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; background:var(--bg); color:#f3f3f3; margin:20px; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale; }
    header { display:flex; align-items:center; justify-content:space-between; gap:16px; flex-wrap:wrap; margin-bottom:12px; }
    h1 { margin:0; color:var(--accent); font-size:20px; text-align:left; letter-spacing:0.2px; }

    .winners-strip {
      display:flex; gap:12px; align-items:stretch;
      background:linear-gradient(180deg,var(--panel),var(--panel-2));
      border:1px solid rgba(255,255,255,0.04); padding:8px; border-radius:8px; box-shadow:0 6px 18px var(--shadow);
      color:#f0f0f0; min-width:0; flex:1 1 420px; backdrop-filter: blur(4px);
    }
    .winners-col { display:flex; flex-direction:column; gap:6px; min-width:0; flex:1; }
    .winners-title { color:var(--accent); font-size:13px; margin:0 0 4px 0; font-weight:600; }
    .winner-row { display:flex; align-items:center; gap:8px; background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00)); padding:6px 8px; border-radius:6px; font-size:13px; overflow:hidden; white-space:nowrap; text-overflow:ellipsis; transition: transform 160ms ease, background 160ms ease; }
    .winner-row:hover { transform: translateY(-3px); background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.00)); }
    .medal { width:22px; text-align:center; font-size:14px; color:#111; }
    .winner-name { flex:1; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; color:#e8e8e8; }
    .winner-val { color:var(--muted); font-size:12px; margin-left:6px; }

    .winners-controls { display:flex; align-items:center; gap:8px; }
    .toggle-btn { background:transparent; border:1px solid rgba(255,255,255,0.04); color:#f0f0f0; padding:6px 8px; border-radius:6px; cursor:pointer; font-size:13px; }

    table { width:100%; border-collapse:collapse; margin-top:12px; background:linear-gradient(#161616,#141414); border-radius:6px; overflow:hidden; }
    thead th { border-bottom:1px solid rgba(255,255,255,0.04); }
    th, td { border:1px solid rgba(255,255,255,0.03); padding:8px 10px; text-align:center; vertical-align:middle; }
    th { background:linear-gradient(180deg,#222,#1b1b1b); color:var(--accent); cursor:pointer; position:sticky; top:0; z-index:2; font-weight:600; font-size:13px; }
    tr:nth-child(even) { background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00)); }
    tr:hover { background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.00)); }

    a { color:var(--link); text-decoration:none; }
    a:hover { text-decoration:underline; }

    .oldVal { color:var(--muted); font-size:0.9em; margin-left:6px; }
    .pos { color:var(--green); font-weight:700; margin-left:6px; }
    .neg { color:var(--red); font-weight:700; margin-left:6px; }
    .zero { color:var(--muted); font-weight:700; margin-left:6px; }

    td.num, th.num { font-variant-numeric: tabular-nums; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", "Courier New", monospace; }

    .table-compact th, .table-compact td { padding:6px 8px; font-size:13px; }
    .table-compact tbody tr { height:36px; }

    tbody tr { position:relative; transition: transform 180ms cubic-bezier(.2,.9,.2,1), box-shadow 180ms cubic-bezier(.2,.9,.2,1); }
    tbody tr::before { content:""; position:absolute; left:6px; top:8px; bottom:8px; width:4px; border-radius:4px; background:transparent; transition: background 160ms ease, width 160ms ease, left 160ms ease; pointer-events:none; }
    tbody tr:hover, tbody tr:focus-within { transform: translateY(-4px); box-shadow: 0 12px 30px rgba(0,0,0,0.6); z-index:1; }
    tbody tr:hover::before, tbody tr:focus-within::before { background: linear-gradient(180deg,var(--accent),var(--link)); width:6px; left:4px; }

    td.num { transition: transform 140ms ease, color 140ms ease; }
    tbody tr:hover td.num, tbody tr:focus-within td.num { transform: translateY(-2px); color:#ffffff; }

    .tooltip { position:relative; display:inline-block; }
    .tooltip .tip { position:absolute; left:50%; transform:translateX(-50%) translateY(8px); bottom:100%; min-width:180px; background:#111; color:#fff; padding:8px; border-radius:8px; box-shadow:0 8px 24px rgba(0,0,0,0.6); opacity:0; pointer-events:none; transition:opacity 140ms ease, transform 140ms ease; font-size:13px; z-index:30; }
    .tooltip:focus-within .tip, .tooltip:hover .tip { opacity:1; transform:translateX(-50%) translateY(0); pointer-events:auto; }
    .tip .tip-row { display:flex; justify-content:space-between; gap:8px; margin:4px 0; }
    .tip .tip-row strong { color:var(--accent); font-weight:600; }

    .ripple { position:relative; overflow:hidden; }
    .ripple .ripple-anim { position:absolute; border-radius:50%; background:rgba(255,255,255,0.12); transform: scale(0); animation: ripple 600ms ease-out forwards; pointer-events:none; }
    @keyframes ripple { to { transform: scale(4); opacity:0; } }

    th[data-sort-dir="asc"]::after { content:" ▲"; font-size:11px; color:#ddd; margin-left:6px; }
    th[data-sort-dir="desc"]::after { content:" ▼"; font-size:11px; color:#ddd; margin-left:6px; }

    .badge { display:inline-flex; align-items:center; gap:6px; padding:4px 8px; border-radius:999px; font-size:12px; font-weight:600; color:#111; box-shadow: 0 4px 10px rgba(0,0,0,0.35); margin-left:8px; vertical-align:middle; }
    .badge .rank { display:inline-flex; align-items:center; justify-content:center; width:18px; height:18px; border-radius:50%; font-size:11px; font-weight:700; color:#111; background:rgba(255,255,255,0.9); }
    .badge-1 { background: var(--badge-1); }
    .badge-2 { background: var(--badge-2); }
    .badge-3 { background: var(--badge-3); }

    @media (prefers-reduced-motion: reduce) {
      tbody tr, tbody tr::before, td.num, .winner-row { transition: none !important; transform: none !important; box-shadow: none !important; }
      .tooltip .tip { transition: none !important; transform: none !important; }
      .ripple .ripple-anim { display:none !important; }
    }

    @media (max-width:900px) {
      header { flex-direction:column; align-items:flex-start; gap:8px; }
      .winners-strip { flex-direction:column; width:100%; }
      th, td { padding:6px 8px; font-size:13px; }
    }
  </style>
</head>
<body>
  <header>
    <h1>Chewbooty Guild Roster</h1>

    <div style="display:flex; align-items:center; gap:12px; min-width:0;">
      <div id="winnersContainer" class="winners-strip" aria-live="polite">
        <div class="winners-col" id="gpGrowth">
          <div class="winners-title">Total GP Growth</div>
          <div class="winner-row"><div class="medal">—</div><div class="winner-name">No positive growth</div><div class="winner-val"></div></div>
        </div>

        <div class="winners-col" id="scoreGrowth">
          <div class="winners-title">Total Score Growth</div>
          <div class="winner-row"><div class="medal">—</div><div class="winner-name">No positive growth</div><div class="winner-val"></div></div>
        </div>
      </div>

      <div class="winners-controls">
        <button id="toggleWinners" class="toggle-btn" aria-expanded="true" aria-controls="winnersContainer">Hide winners</button>
        <button id="compactToggle" class="toggle-btn" aria-pressed="false">Compact</button>
      </div>
    </div>
  </header>

  <table id="guildTable" class="">
    <thead>
      <tr>
        <th data-col="Name">Player (link)</th>
        <th data-col="CharacterGP" class="num">Character GP (Prior Month)</th>
        <th data-col="ShipGP" class="num">Ship GP (Prior Month)</th>
        <th data-col="TotalGP" class="num">Total GP (Prior Month)</th>
        <th data-col="LeagueId">League</th>
        <th data-col="SkillRating">Skill Rating</th>
        <th data-col="ModScore" class="num">Mod Score (Prior Month)</th>
        <th data-col="GearScore" class="num">Gear Score (Prior Month)</th>
        <th data-col="TotalScore" class="num">Total Score (Prior Month)</th>
        <th data-col="ZetaCount" class="num">Zetas</th>
        <th data-col="OmiCount" class="num">Omicrons</th>
        <th data-col="Speed20" class="num">Speed ≥20</th>
        <th data-col="Speed25" class="num">Speed ≥25</th>
        <th data-col="UltimateGLCount" class="num">Ultimate GL</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

<script>
const FILES = ["ChewbootyOld.csv","Chewbooty.csv"];

Promise.all(FILES.map(f => fetch(f).then(r => {
  if (!r.ok) throw new Error(`Failed to fetch ${f}: ${r.status}`);
  return r.text();
})))
  .then(([oldCSV, newCSV]) => renderComparison(oldCSV, newCSV))
  .catch(err => {
    console.error("Error loading CSVs:", err);
    const tbody = document.querySelector("#guildTable tbody");
    tbody.innerHTML = `<tr><td colspan="14" style="color:#f88; text-align:center;">Error loading CSV files. Check console for details.</td></tr>`;
  });

function parseCSV(csvText) {
  if (!csvText) return { header: [], data: [] };
  const lines = csvText.replace(/\r\n/g, "\n").replace(/\r/g, "\n").split("\n").filter(l => l.trim() !== "");
  const rows = lines.map(line => {
    const out = [];
    let cur = "", inQuote = false;
    for (let i = 0; i < line.length; i++) {
      const ch = line[i], next = line[i+1];
      if (ch === '"' && inQuote && next === '"') { cur += '"'; i++; }
      else if (ch === '"') { inQuote = !inQuote; }
      else if (ch === ',' && !inQuote) { out.push(cur); cur = ""; }
      else { cur += ch; }
    }
    out.push(cur);
    return out.map(c => c.replace(/^"|"$/g, "").trim());
  });
  const header = rows.length ? rows[0].map(h => h.replace(/^\uFEFF/, "").trim()) : [];
  const data = rows.slice(1);
  return { header, data };
}

function formatDiff(diff, decimals = 0) {
  const cls = diff > 0 ? "pos" : diff < 0 ? "neg" : "zero";
  const val = typeof diff === "number"
    ? (decimals > 0 ? diff.toFixed(decimals) : Number(diff).toLocaleString())
    : diff;
  const sign = (typeof diff === "number" && diff > 0) ? "+" : "";
  const span = document.createElement("span");
  span.className = cls;
  span.textContent = sign + val;
  return span;
}

function getIndexMap(header) { const map = {}; header.forEach((h,i)=>map[h]=i); return map; }
function escapeHtml(str){ if (typeof str !== "string") return ""; return str.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;"); }
function extractLeadingNumber(text){ if (!text) return 0; const m = text.replace(/[,+]/g,"").match(/-?\d+(\.\d+)?/); return m ? Number(m[0]) : 0; }

/* Build a td with safe DOM nodes (no innerHTML for content) */
function buildNumericCell(current, old, diff, decimals = 0) {
  const td = document.createElement("td");
  td.className = "num";
  td.appendChild(document.createTextNode(typeof current === "number" ? current.toLocaleString() : String(current)));
  const oldSpan = document.createElement("span");
  oldSpan.className = "oldVal";
  oldSpan.textContent = `(${typeof old === "number" ? old.toLocaleString() : String(old)})`;
  td.appendChild(document.createTextNode(" "));
  td.appendChild(oldSpan);
  td.appendChild(document.createTextNode(" "));
  const diffSpan = formatDiff(diff, decimals);
  td.appendChild(diffSpan);
  return td;
}

function buildTextCell(text) {
  const td = document.createElement("td");
  td.textContent = text;
  return td;
}

function buildTooltipCell(currentText, oldText, diff, tooltipRows = []) {
  const td = document.createElement("td");
  td.className = "num tooltip ripple";
  td.setAttribute("data-cur", String(currentText));
  td.setAttribute("data-diff", String(diff));
  const main = document.createElement("span");
  main.className = "cell-main";
  main.textContent = currentText;
  td.appendChild(main);
  td.appendChild(document.createTextNode(" "));
  const oldSpan = document.createElement("span");
  oldSpan.className = "oldVal";
  oldSpan.textContent = `(${oldText})`;
  td.appendChild(oldSpan);
  td.appendChild(document.createTextNode(" "));
  td.appendChild(formatDiff(diff, typeof diff === "number" && String(diff).indexOf('.') !== -1 ? 2 : 0));

  const tip = document.createElement("div");
  tip.className = "tip";
  tip.setAttribute("role","tooltip");
  tooltipRows.forEach(r => {
    const row = document.createElement("div");
    row.className = "tip-row";
    const strong = document.createElement("strong");
    strong.textContent = r[0];
    const span = document.createElement("span");
    span.textContent = r[1];
    row.appendChild(strong);
    row.appendChild(span);
    tip.appendChild(row);
  });
  td.appendChild(tip);
  return td;
}

function renderComparison(oldText, newText) {
  const old = parseCSV(oldText);
  const newer = parseCSV(newText);
  const newMap = getIndexMap(newer.header);
  const oldMap = getIndexMap(old.header);
  const tbody = document.querySelector("#guildTable tbody");
  tbody.innerHTML = "";

  const headerCount = document.querySelectorAll("#guildTable thead th").length;

  newer.data.forEach(row => {
    const allyNew = (row[newMap["AllyCode"]] || "").trim();
    let oldRow = null;
    if (allyNew && oldMap["AllyCode"] !== undefined) {
      oldRow = old.data.find(r => (r[oldMap["AllyCode"]]||"").trim() === allyNew);
    }
    if (!oldRow && oldMap["Name"] !== undefined) {
      const nameNew = (row[newMap["Name"]] || "").trim();
      oldRow = old.data.find(r => (r[oldMap["Name"]]||"").trim() === nameNew);
    }

    const newCharGP = Number(row[newMap["CharacterGP"]] || 0);
    const newShipGP = Number(row[newMap["ShipGP"]] || 0);
    const newTotalGP = newCharGP + newShipGP;
    const newModScore = Number(row[newMap["ModScore"]] || 0);
    const newGearScore = Number(row[newMap["GearScore"]] || 0);
    const newTotalScore = Number(row[newMap["TotalScore"]] || 0);
    const newZetas = Number(row[newMap["ZetaCount"]] || 0);
    const newOmis = Number(row[newMap["OmiCount"]] || 0);
    const newSpeed20 = Number(row[newMap["Speed20"]] || 0);
    const newSpeed25 = Number(row[newMap["Speed25"]] || 0);
    const newGLs = Number(row[newMap["UltimateGLCount"]] || 0);

    const oldCharGP = oldRow ? Number(oldRow[oldMap["CharacterGP"]] || 0) : 0;
    const oldShipGP = oldRow ? Number(oldRow[oldMap["ShipGP"]] || 0) : 0;
    const oldTotalGP = oldCharGP + oldShipGP;
    const oldModScore = oldRow ? Number(oldRow[oldMap["ModScore"]] || 0) : 0;
    const oldGearScore = oldRow ? Number(oldRow[oldMap["GearScore"]] || 0) : 0;
    const oldTotalScore = oldRow ? Number(oldRow[oldMap["TotalScore"]] || 0) : 0;
    const oldZetas = oldRow ? Number(oldRow[oldMap["ZetaCount"]] || 0) : 0;
    const oldOmis = oldRow ? Number(oldRow[oldMap["OmiCount"]] || 0) : 0;
    const oldSpeed20 = oldRow ? Number(oldRow[oldMap["Speed20"]] || 0) : 0;
    const oldSpeed25 = oldRow ? Number(oldRow[oldMap["Speed25"]] || 0) : 0;
    const oldGLs = oldRow ? Number(oldRow[oldMap["UltimateGLCount"]] || 0) : 0;

    const diffCharGP = newCharGP - oldCharGP;
    const diffShipGP = newShipGP - oldShipGP;
    const diffTotalGP = newTotalGP - oldTotalGP;
    const diffMod = newModScore - oldModScore;
    const diffGear = newGearScore - oldGearScore;
    const diffTotalScore = newTotalScore - oldTotalScore;
    const diffZetas = newZetas - oldZetas;
    const diffOmis = newOmis - oldOmis;
    const diffSpeed20 = newSpeed20 - oldSpeed20;
    const diffSpeed25 = newSpeed25 - oldSpeed25;
    const diffGLs = newGLs - oldGLs;

    const playerName = (row[newMap["Name"]] || "").trim();
    const tdName = document.createElement("td");
    tdName.style.textAlign = "left";
    tdName.setAttribute("data-name", playerName.toLowerCase());
    if (allyNew) {
      const a = document.createElement("a");
      a.href = `https://swgoh.gg/p/${encodeURIComponent(allyNew)}/`;
      a.target = "_blank";
      a.rel = "noopener noreferrer";
      a.textContent = playerName;
      tdName.appendChild(a);
    } else {
      tdName.textContent = playerName;
    }

    const tr = document.createElement("tr");
    tr.appendChild(tdName);

    tr.appendChild(buildNumericCell(newCharGP, oldCharGP, diffCharGP, 0));
    tr.appendChild(buildNumericCell(newShipGP, oldShipGP, diffShipGP, 0));

    tr.appendChild(buildTooltipCell(newTotalGP.toLocaleString(), oldTotalGP.toLocaleString(), diffTotalGP, [
      ["Change", diffTotalGP > 0 ? `+${diffTotalGP.toLocaleString()}` : diffTotalGP.toLocaleString()],
      ["Char GP", newCharGP.toLocaleString()],
      ["Ship GP", newShipGP.toLocaleString()]
    ]));

    tr.appendChild(buildTextCell(row[newMap["LeagueId"]] || ""));
    tr.appendChild(buildTextCell(row[newMap["SkillRating"]] || ""));

    tr.appendChild(buildNumericCell(newModScore, oldModScore, diffMod, 2));
    tr.appendChild(buildNumericCell(newGearScore, oldGearScore, diffGear, 2));

    tr.appendChild(buildTooltipCell(newTotalScore.toFixed(2), oldTotalScore.toFixed(2), diffTotalScore, [
      ["Change", diffTotalScore > 0 ? `+${diffTotalScore.toFixed(2)}` : diffTotalScore.toFixed(2)],
      ["Mod", newModScore.toFixed(2)],
      ["Gear", newGearScore.toFixed(2)]
    ]));

    tr.appendChild(buildNumericCell(newZetas, oldZetas, diffZetas, 0));
    tr.appendChild(buildNumericCell(newOmis, oldOmis, diffOmis, 0));
    tr.appendChild(buildNumericCell(newSpeed20, oldSpeed20, diffSpeed20, 0));
    tr.appendChild(buildNumericCell(newSpeed25, oldSpeed25, diffSpeed25, 0));
    tr.appendChild(buildNumericCell(newGLs, oldGLs, diffGLs, 0));

    // Normalization: ensure exact number of cells as headers
    (function normalizeRowCells(trEl) {
      const headerCountNow = headerCount;
      while (trEl.children.length < headerCountNow) {
        const td = document.createElement("td");
        td.textContent = "";
        trEl.appendChild(td);
      }
      while (trEl.children.length > headerCountNow) {
        const extra = trEl.removeChild(trEl.lastElementChild);
        const lastIdx = headerCountNow - 1;
        const lastCell = trEl.children[lastIdx];
        // append a separator and the extra text content (preserve text only)
        lastCell.appendChild(document.createTextNode(" "));
        lastCell.appendChild(document.createTextNode(extra.textContent || ""));
      }
    })(tr);

    tbody.appendChild(tr);
  });

  makeSortable();
  addTopThreeBadges();
  renderWinnersStrip();
  attachRippleHandler();
}

/* Sorting */
function makeSortable() {
  const headers = document.querySelectorAll("th[data-col]");
  headers.forEach(th => {
    th.style.userSelect = "none";
    if (!th.dataset.sortDir) th.dataset.sortDir = "";
    th.onclick = () => {
      const col = th.getAttribute("data-col");
      const current = th.dataset.sortDir || "";
      let newDir;
      if (current === "") newDir = (col === "Name") ? "asc" : "desc";
      else if (current === "asc") newDir = "desc";
      else newDir = "asc";
      headers.forEach(h => h.dataset.sortDir = "");
      th.dataset.sortDir = newDir;
      sortTable(col, newDir);
      headers.forEach(h => h.style.opacity = h === th ? "1" : "0.95");
    };
  });
}

function sortTable(col, dir) {
  const table = document.getElementById("guildTable");
  const rows = Array.from(table.tBodies[0].rows);
  const headerCells = Array.from(table.tHead.rows[0].cells);
  const idx = headerCells.findIndex(c => c.getAttribute("data-col") === col);
  if (idx === -1) return;
  if (!dir) {
    const th = headerCells[idx];
    dir = th && th.dataset.sortDir ? th.dataset.sortDir : (col === "Name" ? "asc" : "desc");
  }

  rows.sort((a, b) => {
    if (col === "Name") {
      const nameA = (a.cells[0].getAttribute("data-name") || a.cells[0].innerText || "").toLowerCase();
      const nameB = (b.cells[0].getAttribute("data-name") || b.cells[0].innerText || "").toLowerCase();
      if (nameA < nameB) return dir === "asc" ? -1 : 1;
      if (nameA > nameB) return dir === "asc" ? 1 : -1;
      return 0;
    } else {
      const numA = extractLeadingNumber(a.cells[idx].innerText);
      const numB = extractLeadingNumber(b.cells[idx].innerText);
      if (numA === numB) return 0;
      return dir === "asc" ? (numA - numB) : (numB - numA);
    }
  });

  rows.forEach(r => table.tBodies[0].appendChild(r));
}

/* Badges (integrated) */
function addTopThreeBadges() {
  const table = document.getElementById("guildTable");
  const rows = Array.from(table.tBodies[0].rows);
  const TOTAL_GP_IDX = 3;
  const TOTAL_SCORE_IDX = 8;

  rows.forEach(r => {
    [TOTAL_GP_IDX, TOTAL_SCORE_IDX].forEach(idx => {
      const cell = r.cells[idx];
      if (!cell) return;
      const existing = cell.querySelectorAll('.badge');
      existing.forEach(e => e.remove());
    });
  });

  function awardByDiff(idx) {
    const ranked = rows.map(r => {
      const cell = r.cells[idx];
      const diff = Number(cell.getAttribute("data-diff") || 0);
      const name = r.cells[0].innerText || "";
      return { cell, diff, name, row: r };
    })
    .filter(e => e.diff > 0)
    .sort((a,b) => b.diff - a.diff);

    ranked.slice(0,3).forEach((entry, i) => {
      const badge = document.createElement('span');
      badge.className = 'badge badge-' + (i+1);
      const rank = document.createElement('span');
      rank.className = 'rank';
      rank.textContent = String(i+1);
      const label = document.createElement('span');
      label.className = 'label';
      const diffText = (typeof entry.diff === 'number') ? (entry.diff > 0 ? `+${Number(entry.diff).toLocaleString()}` : `${Number(entry.diff).toLocaleString()}`) : '';
      label.textContent = diffText;
      badge.appendChild(rank);
      badge.appendChild(label);
      entry.cell.appendChild(badge);
    });

    return ranked.slice(0,3);
  }

  const gpWinners = awardByDiff(TOTAL_GP_IDX);
  const scoreWinners = awardByDiff(TOTAL_SCORE_IDX);

  table._gpWinners = gpWinners;
  table._scoreWinners = scoreWinners;

  if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
    if (gpWinners[0]) burstConfetti(gpWinners[0].row, 12);
    if (scoreWinners[0]) burstConfetti(scoreWinners[0].row, 12);
  }
}

/* Render winners strip without duplicates (dedupe across both categories) */
function renderWinnersStrip() {
  const tableEl = document.getElementById("guildTable");
  const gpWinners = tableEl._gpWinners || [];
  const scoreWinners = tableEl._scoreWinners || [];
  const gpContainer = document.getElementById("gpGrowth");
  const scoreContainer = document.getElementById("scoreGrowth");

  gpContainer.querySelectorAll(".winner-row").forEach(n => n.remove());
  scoreContainer.querySelectorAll(".winner-row").forEach(n => n.remove());

  // Build a map of unique names to their best appearance per category
  function uniqueList(winners) {
    const seen = new Set();
    const out = [];
    winners.forEach((w) => {
      const name = (w.name || "").trim() || "Unknown";
      if (seen.has(name)) return;
      seen.add(name);
      out.push(w);
    });
    return out;
  }

  const uniqueGP = uniqueList(gpWinners);
  const uniqueScore = uniqueList(scoreWinners);

  function renderCategory(container, winners) {
    if (!winners.length) {
      const row = document.createElement("div");
      row.className = "winner-row";
      row.innerHTML = `<div class="medal">—</div><div class="winner-name">No positive growth</div><div class="winner-val"></div>`;
      container.appendChild(row);
      return;
    }
    winners.forEach((w, i) => {
      const nameText = (w.name || "").trim() || "Unknown";
      const valueText = (typeof w.diff === "number") ? (w.diff > 0 ? `+${Number(w.diff).toLocaleString()}` : `${Number(w.diff).toLocaleString()}`) : "";
      const row = document.createElement("div");
      row.className = "winner-row";
      const badgeEl = document.createElement('span');
      badgeEl.className = 'badge badge-' + (i+1);
      const rank = document.createElement('span');
      rank.className = 'rank';
      rank.textContent = String(i+1);
      const label = document.createElement('span');
      label.className = 'label';
      label.textContent = nameText;
      badgeEl.appendChild(rank);
      badgeEl.appendChild(document.createTextNode(' '));
      badgeEl.appendChild(label);
      const nameDiv = document.createElement('div');
      nameDiv.className = 'winner-name';
      nameDiv.textContent = nameText;
      const valDiv = document.createElement('div');
      valDiv.className = 'winner-val';
      valDiv.textContent = valueText;
      row.appendChild(badgeEl);
      row.appendChild(nameDiv);
      row.appendChild(valDiv);
      container.appendChild(row);
    });
  }

  renderCategory(gpContainer, uniqueGP);
  renderCategory(scoreContainer, uniqueScore);
}

/* Ripple handler */
function attachRippleHandler() {
  const table = document.getElementById("guildTable");
  if (!table._rippleAttached) {
    table.addEventListener('click', e => {
      const cell = e.target.closest('td.ripple');
      if (!cell) return;
      if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) return;
      const r = document.createElement('span');
      r.className = 'ripple-anim';
      const rect = cell.getBoundingClientRect();
      const size = Math.max(rect.width, rect.height) * 1.2;
      r.style.width = r.style.height = size + 'px';
      r.style.left = (e.clientX - rect.left - size/2) + 'px';
      r.style.top = (e.clientY - rect.top - size/2) + 'px';
      cell.appendChild(r);
      setTimeout(()=> r.remove(), 700);
    });
    table._rippleAttached = true;
  }
}

/* Confetti */
function burstConfetti(containerRow, count=18) {
  if (!containerRow || window.matchMedia('(prefers-reduced-motion: reduce)').matches) return;
  const colors = ['#ffd166','#66d9ff','#9be564','#ff7ab6','#ffd1a9'];
  const rect = containerRow.getBoundingClientRect();
  const centerX = rect.left + rect.width/2;
  const centerY = rect.top + rect.height/2;
  for (let i=0;i<count;i++){
    const el = document.createElement('div');
    el.style.position='fixed';
    el.style.width='8px'; el.style.height='8px';
    el.style.background = colors[i%colors.length];
    el.style.borderRadius='2px';
    el.style.left = centerX + 'px';
    el.style.top = centerY + 'px';
    el.style.opacity = '1';
    el.style.pointerEvents = 'none';
    el.style.transform = `translate(0,0) rotate(${Math.random()*360}deg)`;
    el.style.transition = `transform 900ms cubic-bezier(.2,.8,.2,1), opacity 900ms`;
    document.body.appendChild(el);
    const dx = (Math.random()-0.5) * 300;
    const dy = (Math.random()-0.8) * 300;
    requestAnimationFrame(()=> {
      el.style.transform = `translate(${dx}px, ${dy}px) rotate(${Math.random()*720}deg)`;
      el.style.opacity = '0';
    });
    setTimeout(()=> el.remove(), 950);
  }
}

/* Compact toggle */
(function attachCompactToggle(){
  const btn = document.getElementById("compactToggle");
  const table = document.getElementById("guildTable");
  if (!btn || !table) return;
  btn.addEventListener("click", () => {
    const isCompact = table.classList.toggle("table-compact");
    btn.setAttribute("aria-pressed", String(isCompact));
    btn.textContent = isCompact ? "Normal" : "Compact";
  });
})();

/* Winners strip toggle */
(function attachToggle(){
  const btn = document.getElementById("toggleWinners");
  const container = document.getElementById("winnersContainer");
  if (!btn || !container) return;
  btn.addEventListener("click", () => {
    const isHidden = container.style.display === "none";
    container.style.display = isHidden ? "flex" : "none";
    btn.textContent = isHidden ? "Hide winners" : "Show winners";
    btn.setAttribute("aria-expanded", String(isHidden));
  });
})();
</script>
</body>
</html>
